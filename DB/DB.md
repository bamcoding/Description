# 정보처리기사
# OCJP
# SQLP

자바 컬렉션 정리
자바에서 컬렉션이란 데이터의 집합 그룹을 의미하며

상황 액션 결과

액션을 뺸다.

과제가 주어지면 꾸준히 책임지고 수행합니다.
제 성과를 꾸준히 쌓아나가도록하겠습니다.



안녕하세요. 자바 스프링 웹개발 6년차 이근재입니다.




작은 일이라도 한번 시작하면 끝을 보자라는 마음으로 한번 시작한 것들을 꾸준히 해 나갔고 
그 결과 프로젝트에 채택되어 좋은 성과를 이루었다고 생각합니다.
한발한발 꾸준히 해나가는것으로 성과를 쌓아나가도록하겠습니다.

# 자바
JVM 운영체제에 상관없이 실행가능
GC 자동으로 메모리 관리 안정성
객체지향언어이구요

## 런타임
- .java Source code파일은 컴파일러가 .class byte code로 변경해준다.
- Class Loader가 런타임 데이터 영역으로 로딩시킴 프로그램 실행
- 메소드, 힙, 스텍, 레지스트, 네이티브 매소드 스택


## 컬렉션이란 무엇인가
해당 객체는 여러 원소들을 담을 수 있는 자료구조.
데이터의 모아서 사용하는 자료구조 입니다.
### 리스트
- 어레이리스트,링크드리스트가 있다. 리스트는 배열과 비슷한 자바의 자료형으로 배열보다 편리한 기능을 가지고 있다
- 어레이리스 자바의 백터를 개선한 배열로 구현된 리스트입니다.
- 링크드리스트는 다음 노드의 주소를 기억하고 있는 리스트로 배열에 비해 삽입과 삭제가 간단하다는 장점이 있습니다.
- 하지만 탐색의 경우에는 첫번째 노드부터 탐생해 나가기 때문에 느리다는 단점이 있습니다.

### 맵
- 해시맵, 트리맵, 링크드해시맵이 있는데 해시맵을 일반적으로 사용합니다.
- 해시맵은 해시테이블을 사용하며 키값에 해시함수를 적용하여 나온 인덱스에 값을 저장하는 식입니다. 중복을 허용하지 않으며 순서가 없습니다.
- 트리맵은 레드 블랙트리 자료구조를 사용한 맵이고 트리구조이기 때문에 어느정도 순서가 보장된다.
- 링크드해시맵은 링크드리스트로 구현된 맵입니다.

### 셋
- 해시셋은 해시맵에서 키값이 없는 자료형
- 트리셋
- 링크드해시셋

### 스택과 큐
- 데이터를 기록하는 자료구조이며
- 큐는 선입선출, 스택은 후입선출입니다.

### 어레이와 어레이리스트의 다른점
- 어레이는 렝스 변수 어레이리스트는 사이즈
- 어레이는 크리가 고정
- 어레이는 기본형 참조형 변수를 담을 수 있다.


## 오버라이딩과 오버로딩
- 오버라이딩: 부모 클래스의 기능을 재정의한 것, 추상화 메소드를 재정의 할 때,
- 오버로딩: 상속과 관련이 없습니다. 같은 이름의 메소드를 형태가 다르게 생성할 수 있다. 파라미터가 다르거나 리턴 값이 다르거나

## 싱크로나이즈드
- 멀티스레드 환경에서 여러 스레드가 동일한 리소스에 접근하려고 하는 경우 동시성 문제로 인해서 예기치 않은 결과를 생성할 수 있다.
- 해당 예약어로 동기화 메소드 혹은 코드 블록을 지정하여 스레드 동기화를 제공한다. 스레드 사이의 실행순서 제어
- 오브젝트의 인스턴스에 모니터(열쇠)라는 개념이 있다. 열쇠가 하나여야한다.

# 스프링, 스프링부트
## 스프링과 스프링 부트의 차이점
- 엔터프라이즈 애플리케이션을 보다 쉽게 만들 수 있다. 시간비용이 단축되어 생성성이 좋다.
- DI, IOC 느슨한 결합도 높은 응집도를 제공한다. 
- AOP로 로깅, 트랜잭션 처리를 공통으로 관리할 수 있게 해준다.

## 스프링 부트
- 최소한의 설정으로 스프링 프레임워크를 사용하게 해준다.
- 스프링부트 스타터라는 의존성을 통해서 자동설정, 버전관리가 가능하다.
- 클래스와 멤버변수,메소드에 컴포넌트 스캔, 오토와이어드 등의 어노테이션을 통해서 스프링부트가 알아서 설정을 해준다.  @EnableAutoConfigration

## 메이븐과 그래이들의 특징
- 자바의 빌드 관리 툴입니다. 프로젝트에 필요한 xml, properties, jar 파일은 인식하고 빌드해주는 도구
- 소스 코드를 컴파일, 테스트, 정적분석 등을 하여 실행가능한 앱으로 빌드해줌
- 외부 라이브러리를 참조하여 자동으로 다운로드 및 업데이트의 관리해줌
- 자바의 대표적인 빌드 도구: Ant, Maven, Gradle
### Ant
- XML기반의 빌드 스크립트
- 자유로운 빌드 단위 지정
- 간단하고 사용하기 쉬움
- 대규모 프로젝트에서 복잡해지는 경향이 있음
- 라이프 사이클이 없어서 빌드 순서를 개발자가 재정의 해야함
### 메이븐
- 예전에는 ant를 사용하고 있었는데 이것을 대체하기 위해서 만들어졌습니다.
- pom.xml 파일에서 라이브러리를 관리할 수 있다. xml 기반의 빌드 스크립트에 라이프 사이클 도입됨
- 참조한 외부 라이브러리에 연관된 다른 라이브러리도 자동으로 관리됨.
- 기존에 사용하던 Ant는 빌드의 기능만 가지고 있음. 그외에는 개발자가 관리해야 했었다.
- 자동으로 라이브러리를 관리해주는 기능이 추가된 메이븐을 사용하게 되었습니다. 다운받아 사용하던 라이브러리에 변동 사항이 있으면 자동으로 업데이트하여 적용됨
### 그래이들
- 그루비 스크립트를 황용한 빌드 관리 도구
- 안드로이드 프로젝트의 표준 빌드 도구이며 멀티 프로젝트의 빌드에 최적화되어 있다.
- 메이븐에 비해 더 빠른 처리속도를 가지고 있으며 간결한 구성이 가능하다.
- build.gradle

## 어노테이션에 대해서 아는것


# 관계형 데이터 베이스
## 1.정규화
노멀라이제이션
데이터 상에서 중복을 줄이는 작업
데이터가 꼬이는 것을 방지하기 위해 테이블을 분리하는 작업
이련의 작업으로 무결성을 유지하고 디비의 저장 용량을 줄일 수 있습니다.
### 제1 정규화 위배, 원자성
- 모든 속성은 반드시 하나의 값만 가져야 한다.
- 다중 값을 가진다 [이근재|인스타,네이버,페이스북,구글]
- 반복 그룹을 가진다 [이근재|인스타|네이버|페이스북|구글]
- 1:N관계 직원과 SNS 테이블로 분리
### 제2 정규화
- 모든 속성은 반드시 모든 기본키에 종속되어야 한다.
- [주문코드|주문수량|상품코드|상품명]
- 주문이 발생하지 않으면 음료 입력 불가 -> 입력 이상
- 음료명이 변경될 경우 해당되는 주문 데이터 로우를 업데이트 해야합 -> 수정 이상
- 음료 삭제 시 주문까지 삭제 -> 삭제
- 1:N관계 음료와 주문 테이블로 분리
### 제3 정규형
- 기본키가 아닌 모든 속성간에는 서로 종속 될 수 없다.

## 2.무결성
무결성이란 관계형 데이터베이스에서 데이터의 정확성과 일관성을 보장하기 위한 제약 조건을
- 개체 무결성과 참조 무결성이 있습니다.
- 개체 무결성은 기본키를 구성하는 속성은 널이나 중복값을 가질 수 없다. 유일하게 식별할 수 있는 키어야 한다.
- 참조 무결성은 외래키 값은 널이거나 부모 테이블의 기본키 값과 동일해야 한다.

## 3.트랜잭션
- 여러 쿼리를 논리적으로 하나의 작업으로 묶어주는 것
- 거래가 일어날때 구매자의 계좌에서 출금하고 판매자의 계좌에 입급한다.
- 2개의 업데이트 쿼리로 이루어지는데 쿼리가 수행되는 도중에 서버가 다운되어 1개의 쿼리만 수행되는 경우를 방지하기 위해서 트랜잭션이 나왔다.
- 쿼리들이 한번에 실행되거나 실행되지 않게 하는것 데이터상 안정성을 보장한다.
- 커밋과 롤백
- ACID 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질 
- [원자성 Atomicity] 모두 반영되거나, 전형 반영되지 않아야 한다.
- [일관성 Consistency] 작업처리결과는 항상 일관성 있어야 한다. 제약 조건을 만족해야한다.
- [독립성 Isolation] 둘 이상의 쿼리가 묶여서 작업되는 와중에 다른 클라이언트가 끼어들면 안된다.
- [지속성 Durablity] 트핸잭션이 성공적으로 완료되었으면 결과가 영구히 반영되어야 한다.

독립성을 보장하기 위해서는 100개의 클라이언트가 접근할 경우 순차적으로 처리하여 동시성이 떨어진다.
이 때 격리레벨을 조정하여 동시성을 높일 수 있다.
- READ-UNCOMMITTED 커밋되지 않았지만 변경된 사항을 다른 클라이언트에서 조회할 수 있다. (DIRTY READ) 문제가 발생합니다. 트랜잭션 무효
- READ-COMMITTED 트랜잭션 이전 혹은 완료의 데이터에 접근할 수 있다. 서로 다른값이 조회(non-repeatable read)
- REPEATABLE-READ Phantom read
- SERIALIZABLE 성능은 가장 떨어지지만 ACID가 보장된다.

## 4.인덱스
보통 인덱스를 타면 조회가 빨라진다.
인덱스의 종류에는 비트리, 클러스터드 인덱스, 논 클러스티드 인덱스가 있습니다.
우리가 흔히 사용하는 인덱스는 비트리 인덱스하고 한다.

테이블을 생성할때 오브젝트를 생성한다고 하는데 테이블과 매핑된 하나의 오브젝트가 생성되는 것이다.

인덱스는 저장방식이 인덱스 컬럼 방식으로 소팅되어 저장된다.
보통 테이블은 데이터가 흩어져서 저장되어 있어서 테이블 풀스캔으로 데이터량이 많을수록 시간이 오래걸린다.
특정 조건의 데이터를 검색할 때 시작점을 지정해서 거기서부터 데이터를 검색할 수 있다.
인덱스에서 먼저 데이터를 찾고 테이블에 매핑되어 있는 곳으로 가서 찾는다.

매핑 방식은 객체지향에서 포인트처럼 인덱스가 테이블 블락에 주소를 가지고 있다.
블락은 데이터가 저장되는 최소 단위이고 거기엔 테이블의 데이터 로우단위로 저장되어 있다.
where order by에 사용할 컬럼에 대해 인덱스를 생성하면 효율정이다.
단일 컬럼, 결합 컬럼 인덱스를 생성하면 효율적.

셀렉트는 빠르지만 인서트와 업데이트는 느려지므로 마구잡이로 생성하면 안된다. 

### Cardinality(기수성)
- 인덱스를 생성할 때 속성에 대해서 비교하는 기준입니다.

## 5.조인
관계형 데이터베이스에서 여러개의 테이블을 묶어서 조회하는 기능
이너조인, 아우터조인
네스티드 루프 조인
솔트 머지 조인
해쉬 조인 - 대용량 데이터 처리를 할때 좋다.

## 6.옵티마이저의 역할
쿼리를 수행할 때 최적의 수행경로를 찾아서 수행한다.
로지컬 옵티마이저 최정의 경로
피지컬 옵티마이저 비용계산
잘못된 통계정보로 인해 잘못된 수행계획으로 수행될 수 있는데 이럴 경우
힌트를 사용해서 올바른계획으로 수행할 수 있도록 두움을 줄 수 있다.

















