레이어드 아키텍처 패턴
  레이어드 아키텍처 패턴은 스프링 프로젝트 내부에서 어떻게 코드를 적절히 분리하고 관리할 것이냐에 대한 것이다. 

프리젠테이션 레이어 <> 비즈니스 레이어 <> 퍼시스턴스 레이어 <> 데이터베이스 레이어
     DTO             Model          Entity

REST 아키텍처 스타일
  클라이언트(브라우저)가 우리 서비스를 이용하려면 어떤 형식으로 요청을 보내고 응답을 받는지에 대한 것이다.

REST API
  아키텍처 스타일은 아키텍처 패턴과는 조금 다른데 아키텍처 패턴은 어떤 반복되는 문제 상황을 해결하는 도구이고, 아키텍처 스타일은 반복되는 사키텍처 디자인을 의미한다.
  6가지 제약조건으로 구성된다.

REST 제약조건
 - Client-Server (클라이언트-서버)
 - stateless (상태가 없는)
 - Cacheable (캐시되는 데이터)
 - Uniform Interface (일관적인 인터페이스)
 - Layered System (레이어 시스템)
 - Code-On-Demand (코드-온-디맨드)


스프링 어노테이션

JPA와 스프링 Data JPA




Entity

@Builder 빌드 패턴을 이용하여 객체를 생성할 수 있다. 기존 생성자와 다르게 파라미터 순서를 기억할 필요 없이 객체를 생성할 수 있다.

@NoArgsConstructor 매개변수 없는 생성자를 구현해 준다.

@AllArigsConstructor 클래스의 모든 멤버 변수를 매개변수로 받는 생성자를 구현해 준다.

@Data Getter/Setter 메서드를 구현해 준다.

DTO

서비스가 요청을 처리하고 클라이언트로 반환할 때 모델 자체를 그대로 리턴하는 경우는 별로 없다. 보통은 데이터를 전달하는 데 사용하는 오브젝트인 DTO로 변환해 리턴한다. 왜 그냥 모델을 리턴하지 않고 DTO로 변환해 리턴하는가?

비즈니스 로직 캡슐화를 하기 위함이다.
모델을 데이터베이스 테이블 수조와 매우 유사하다. 모델이 갖고 있는 필드들은 테이블의 스키마와 비슷할 확률이 높다. 대부분의 비즈니스는 외부인이 자사의 데이터베이스의 스키마를 아는 것을 원치 않는다. 
위 변환 작업은 외부 사용자에게 서비스 내부의 로직, 데이터베이스의 구조 등을 숨길 수 있다.

클라이언트가 필요한 정보를 모델이 전부 포함하지 않는 경우가 많기 때문이다. 가장 대표적인 예로 에러 메시지가 있다. 만약 서비스 실행 도중 사용자 에러가 나면 이 에러 메시지를 어디에 포함해야 하는가?

DTO에 에러 메시지 필드를 선언하고 DTO에 포함하면 된다.



